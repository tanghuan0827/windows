java内存模型

synchronized volatile final

3.1 java内存模型的基础
3.1.1 并发编程模型的两个关键问题

	并发编程，需要处理两个关键问题：线程之间如何通信及线程如何同步 
	通信指线程之间以何种机制来交换信息
	线程之间的通信机制有两种：共享内存和消息传递
	
	同步是指程序用于控制不同线程操作发生相对顺序的机制。
	
3.1.2 java内存模型的抽象结构
	实例域 静态域和数组元素都存储在堆内存中，堆内存存在线程之间共享。
	
	局部变量 方法定义参数 异常处理参数 不会再线程之间共享，它们不会有内存可见性问题。
	
	java线程之间的通信由java内存模型控制，JMM决定一个线程对共享变量的写入何时对另一个线程是可见的。
	主内存 线程枝江共享变量存储在主内存中
	私有的本地内存  本地内存存储了该线程以读、写共享变量的副本

	线程A与线程B之间要通信的话
	，必须经历下面两个步骤。
	线程A把本地内存A中更新过的共享变量刷新到主内存中去。
	线程B到主内存中去读取线程A之前已更新过的共享变量。
	
	JMM通过控制主内存与每个线程的本地内存之间的交互，而且这个通信必须要通过主内存。
	
	3.1.3 从源代码到指令序列的重排序
	1 编译器优化的重排序 
	2 指令并行排序
	内存系统的重排序 
	
	============================================================
	3.1.4 并发编程模型的分类
	写缓冲区 处理器 
	允许对读写 进行重排序
	
	============================================================
	3.1.5 happens-before简介
	如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。
	这里提的两个操作可以是在一个线程内，也可以是在不同的线程之间。
	
	重排序 编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。
	
	============================================================
	3.2.1 数据的依赖性
	如果两个操作访问同一个变量，且这两个操作中有一个未写操作，此时这两个操作之间就存在数据的依赖性。
	写后读
	写后写
	读后写
	
	编译器和处理器不会改变存在数据依赖关系的两个操作之间的执行顺序。
	不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。
	
	============================================================
	3.2.2 as-if-serial语义
	as-if-serial 不管怎么重排序（编译器和处理器为了提供并行度）单线程的执行结果不能改变。
	
	不会改变数据的依赖性。
	
	在不改变程序执行结果的前提下，尽可能提高并行度。
	
	============================================================
	3.2.4 重排序堆多线程的影响
	
	============================================================
	3.3 顺序一致性
	程序未正确同步，就可能存在数据竞争
	
	在一个线程中写一个变量
	在另一个线程中读同一个变量
	而且读和写没有通过同步来排序
	
	============================================================
	3.3.2 顺序一致性的内存模型
	顺序一致性内存模型
	一个线程的所有操作必须按照程序的顺序来执行
	所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子操作执行且like对所有的线程可见。
	
	在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，开关装置会把所有线程的所有内存读写操作串行化
	
	============================================================
	3.3.4 未同步程序的执行特性
	
	1）顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。
	2）顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序
	3）JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。
	
	总事务包括读事务和写事务。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存。每个事务都读写内存中一个或多个物理连接的字。
	
	double long对于总线事务不具有一致性。
	
	happens-before
	
	============================================================
	3.4.3 volatile写-读的内存语义
	当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存中。
	
	当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。
	
	当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。
	当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。
	当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。
	
	首先确保正确性，然后再去追求执行效率。
	
============================================================
3.5 锁的内存语义
	锁可以让临界区互斥执行。锁的内存语义。
	
============================================================
3.5.2 锁的释放和获取的内存语义
	当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使的监视器保护的临界区代码必须从主内存中读取共享变量。

============================================================
3.5.4 concurrent包的实现
	
============================================================
3.6.1 final域的重排序规则
	
============================================================
3.6.2 写final域的重排序规则
	写final域的重排序规则禁止把final域的写重排序到构造函数之外。

============================================================
3.7.3 
	136
	
============================================================
3.9.1 处理器的内存模型
	

============================================================
3.9.3 JMM的内存可见性保证
	单线程程序 
	正确同步的多线程程序 
	未正确未正确同步的多线程程序
	
	
	
	
	
	
	
	
	
	
	
	
	














































