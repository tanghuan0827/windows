4.1.1 什么是线程
	在一个进程可以创建多个线程，这些线程都拥有各自的计数器 堆栈 和局部变量属性，并且能够访问共享的内存变量。
	
4.1.2 为什么要使用多线程
	1）更多的处理器核心
	而在一个线程在一个时刻只能运行在一个处理器核心上。
	2） 更快的响应时间
	将数据一致性不强的操作派发给其他线程处理 也可以使用消息队列
	3）更好的编程模型
	
	线程分配到时间片多少也决定了线程使用处理器资源的多少。
	线程的状态
	NEW  初始状态
	RUNNABLE	运行状态
	BLOCKED 阻塞状态
	WAITING 等待状态
	TIME_WAITING  超时等待装
	TREMINATED	终止状态
	
============================================================
4.1.5 Daemon线程
	Daemon线程是一种支持线程，主要被用作后台调度以及支持性工作。
	当一个java虚拟机不存在非Daemon线程的时候，java虚拟机会退出。
	
	java虚拟机中已经没有非Daemon线程，虚拟机需要退出。java虚拟机都需要立即终止，因此DaemonRunner立即终止，但是DaemonRunner中的finally块并没有执行。
	
============================================================
4.2 启动和终止线程
	
============================================================
4.2.1 构造线程
	在运行线程之前首先要构造一个线程对象，线程对象在构造是需要提供所需要的属性，如线程组 线程优先级 是否是Daemon线程等。
	
============================================================
4.2.2 启动线程
	线程对象初始化完成后，调用start方法后就可以启动这个线程。
	在启动一个线程前，最好为这个线程设置线程名称，因为jstack分析线程或者进行问题排查是，就能给开发人员一些提示。
	
============================================================
4.3.2 理解中断
	中断标志位
	
	抛出InterruptedException的线程SleepThread，其中断标志位被清除了，而一直忙碌运行的线程BusyThread，中断标志位没有被清除
	
	suspend resume stop
	不会保证线程的资源正常释放
	
============================================================
4.2.5 安全的终止线程
	交互方式最适合用来取消或者停止任务。
	
	interrupt  on=false
	这种通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止，因此这种终止线程的做法显得更加安全和优雅。
	
============================================================
4.3 线程间的通信
	
	线程开始运行，拥有自己的栈空间
	
============================================================
4.3.1 volatile和synchronized关键字
	java支持多个线程同时访问一个对象或者对象的成员变量，由于每个线程都可以拥有这个变量的拷贝，加速程序的执行，多核处理器的显著特性
	
============================================================
4.3.3 等待/通知的经典范式
	获取对象的锁
	如果条件不满足，那么调用对象的wait方法，被通知后仍然检查条件
	条件满足则执行响应的逻辑
	
============================================================
4.3.4 管道输入/输出流
	它主要用于线程之间的数据传输，而传输的媒介为内存
	管道输入 输出 流主要 PipedOutputStream PipedInputStream PipedReader PipedWriter
	
============================================================
4.3.5 Thread.join()的使用
	每个线程终止的前提是前驱线程终止，每个线程等待前驱线程终止后，才能从join方法返回。这里涉及等待/通知机制
	
	加锁 循环 处理逻辑
	
============================================================
4.3.6 ThreadLocal的使用
	ThreadLocal，即线程变量，是一个以ThreadLocal对象为键，任意对象为值得存储结构。
	
============================================================
4.4 线程应用实例
	4.4.1 等待超时模式
	调用一个方法等待一段时间，如果该方法在给定的时间段内得到结果，那么结果立刻返回，反之，超时返回默认结果。
	
	等待通知机制 增加了超时控制 不会永久阻塞调用者 调用者按时返回
	
============================================================
4.4.2 一个简单的数据库连接池示例
	从连接池获取 使用 释放连接的过程 
	从连接池获取 使用 和释放连接的过程
	
	双向队列来维护连接
	
============================================================
4.4.3 线程池技术及其示例
	消除频繁创建和消亡线程的系统资源开销 
	面对过量任务的提交能够平缓化
	
	线程池的本质就是使用一个线程安全的工作队列连接工作者线程和客户端线程，客户端线程将任务放入到工作者队列后便返回，而工作者线程则不断从工作队列上取出工作并执行。
	当工作队列为空时，所有工作者线程均等待在工作队列上，当有客户端提交了一个任务后会通知一个工作线程，随着大量的任务提交，更多的工作线程会被唤醒。
	
============================================================
4.4.4 一个基于线程池技术的简单web服务器
	等待超时 数据库连接池 简单线程池
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	