java并发机制的底层实现原理
	java代码会在编译后变成java字节码，字节码被加载到JVM里，JVM执行字节码，最终转化为汇编指令在cpu上执行。
	
	volatile是轻量级的synchronized，它在多处理器中保证了共享变量的可见性。
	可见性是指当一个线程修改一个共享变量时，另外一个线程能读到这个修改。
	
	1 volatile的定义与实现原理
	java编程语言运行线程访问共享变量，为了确保共享变量能准确和一致性更新，线程应该确保通过排他锁单独获得这个变量。
	
	内存   缓存行     处理器
	
	Lock的前缀指令在多核处理器会引发两件事情
	将当前处理器缓存行的数据写回到系统内存   锁缓存
	这个写回内存的操作会使其他cpu缓存了该内存地址的数据无效。
	
	64个字节 头结点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会相互锁定。
	
	============================================================
	2.2 synchronized的实现原理与应用
	为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及所的存储结构和升级过程。
	
	对于普通同步方法，锁是当前实例对象
	对于静态同步方法，锁是当前类的Class对象
	对于同步方法块，锁是Synchronized括号里配置的对象
	
	当一个线程试图访问同步代码块时，它首先必须得到锁，退出或者抛出异常时必须释放锁。
	
	monitorenter moniterexit 并与之对应的monitor
	
	============================================================
	2.2.1 Java对象头
	
	============================================================
	2.2.2 锁的升级和对比
	减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁。
	锁一共有关4种状态，
	无锁状态 偏向锁状态 轻量级锁状态 重量级锁状态
	
	锁能升级不能降级
	
	偏向锁 大多数情况下，锁不仅不存在多线程竞争，而是总是由同一个线程多次获取，为了让线程获得锁的代价更低而引入了偏向锁
	
	============================================================
	2 轻量级锁 
	轻量级锁加锁 
	轻量级锁解锁
	
	============================================================
	2.3 原子操作的实现原理
	原子 不能被进一步分隔的最小粒子，原子操作 意为不可被中断的一个或者一列操作
	
	缓存行  比较并交换 CPU流水线 内存顺序冲突
	
	所谓总线锁就是使用处理器提供一个  LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。
	
	使用缓存保证原子性
	总线锁定把CPU和内存之间的通信锁住了，这使得在锁定期间，其他处理器不能操作其他内存地址的数据。
	
	。所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效
	
	
	CAS问题
	ABA问题  因为CAS需要在操作值得实惠，检查值没有发生变化，如果没有发生变化则更新。
	
	循环时间开销大。
	只能保证一个共享变量的原子操作


























