设计优化
	设计模式 组件 和设计方法
	
	单例模式的使用和实现
	代理模式的实现和深入理解
	享元模式的应用
	装饰着模式对性能组件的封装
	观察者模式的使用
	使用Value Object模式减少网络数据传输
	使用业务代理模式添加远程调用缓存
	缓冲和缓存的定义和使用
	对象池的使用原理和基本实现 
	构建负载均衡以及Terracotta框架的简单使用
	时间换空间和空间换时间的基本思路
	
============================================================
2.1	善用设计模式
	2.1.1 单例模式 
	它是一种对象创建模式，用于产生一个对象的具体实现，它可以确保系统中一个类只产生一个实例。
	
	省略重量级的对象的创建时间
	由于new的操作次数减少 ，对系统内存的使用频率也会降低，这将减轻GC压力，缩短GC的停顿时间
	
	private的构造函数
	instance成员变量和getInstance必须是static
	
	仍然有方法可能导致多个单例的实现  通过反射的机制
	
============================================================
2.1.2 代理模式
	代理模式，它使用代理对象完成用户请求，屏蔽用户对真实对象的访问。
	
	主要讨论使用代理模式实现延迟加载，从而提升系统的性能和反应速度。
	
	主题接口 定义代理类和真实主题的公共对外方法，也是代理类真实主题的方法
	真实主题 真正实现业务逻辑的类
	代理类 用来代理和封装真实主题
	Main 客户端 使用代理类和主题接口完成一些工作
	
	使用一个代理对象代替它的原有位置，只要在真正需要的时候，才对它进行加载。
	
============================================================
2.1.3 享元模式 
	在一个系统中存在多个对象，那么只组共享一份对象的拷贝。
	
============================================================
2.1.4 装饰者模式
	代码的复用应尽可能的使用委托而不使用继承。
	
	装饰者和被装饰者都拥有相同的接口Component,被装饰者通常是系统的核心组件，完成特定的功能，而装饰者可以在被装饰者的方法前后，加上特定的前置处理和后置处理，增强装饰者的功能。
	
============================================================
2.1.7 业务代理模式
	
缓冲 
	buffered
	生产者和消费者之间的缓冲区
	
2.2.2 缓存Cache
	缓存主要的作用是暂存数据处理结果，并提供下次访问。
	HashMap

============================================================
2.2.3 对象复用 --池
	对象池化，如果一个类被频繁请求使用，那么不必每次都生成一个实例，放入池中，需要的时候才取出来使用。
	线程池和数据库连接池
	
============================================================
2.2.4 并行替代串行
	
============================================================
2.2.5 负载均衡

	








































