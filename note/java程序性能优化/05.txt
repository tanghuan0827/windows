	JVM内存模型结构
	与内存分配（尤其堆分配）相关的JVM参数
	垃圾收集器的种类以及使用方法
	一些常用的JVM调优参数及使用效果
	一个JVM调优的实例介绍
	
	程序计数器  当线程超过CPU数量，线程之间根据时间片轮询抢夺CPU资源
	
	每个线程必须用一个独立的程序计数器
	
	Java虚拟机栈 也是线程私有的内存空间，两种异常与栈空间有关  
		StackOverflowError  OutOfMemoryError
	
	调大虚拟机栈 空间明显上升
		-Xss1M
		
	方法调用 入栈
	方法返回 出栈
	
	随着函数参数的增加和局部变量的增加，单次函数调用对栈空间的需求也会增加
	
	jsclasslib 可以查看class文件中每个方法所分配的最大局部变量表的容量
	可以查看class文件结构，包括常量池 接口 属性 方法 还可以查看字节码
	
============================================================
5.1.3 本地方法栈
	本地方法栈和Java虚拟机栈的功能很相似，
	本地方法栈用于管理本地方法的调用

============================================================
5.1.4 Java堆
	几乎所有的对象和数组都是在堆中分配空间，java堆分为新生代和老年代两个部分
	新生代又可以进一步分为eden,survivor space(s0或者from space)和suvivor space1(s1或者to space)
	
	eden为对象的出生地，s0 和s1至少经历过一次垃圾回收了
	
	-XX:+PrintGCDetails 
	-XX:SurvivorRatio=8 
	-XX:MaxTenuringThreshold=15 
	-Xms40M
	-Xmx40M 
	-Xmn20M

============================================================
5.1.5 方法区
	与堆空间类似，它也是被JVM中的所有线程共享，方法区主要保存信息是类的元数据。
	
	方法区中最为重要的是类的类型信息，常量池，域信息，方法信息。
	方法区也被称为永久区。
	
============================================================
5.2 JVM内存分配参数
	5.2.1 设置最大堆内存
	-Xmx13M
	Java应用程序 可以使用最大堆 可以用-Xmx参数指定，最大堆指的是新生代和老年代的大小之和的最大值，它是Java应用程序的上限。
	
	5.2.2 设置最小堆内存
	-Xms
	java程序在运行的时候，首先会被分配-Xms指定内存大小，并尝试这个空间运行程序。若超过-Xmx的值，则抛出OutOfMemoryError异常
	
	最小堆内存设置过小，会增加Minor GC和Full GC的次数，堆系统性能产生一定的影响。
	
	-Xmx11M -Xms4M -verbose:gc
	当系统内存实际使用量触及-Xms指定大小，会触发Full GC
	
============================================================
5.2.3 设置新生代
	设置一个较大的新生代会减小老年代的大小。
	新生代一般设置为整个堆空间的1/4到1/3左右
	
	新生代设置为2MB
	-Xmx11M -Xms11M -Xmn2M -XX:+PrintGCDetails
	
============================================================
5.2.4 设置持久代
	-XX:MaxPermSize 设置持久代的最大值
	-XX:PermSize    设置持久代的初始大小
	
	一般设置为64M 或者128M
	
============================================================
5.2.5 设置线程栈
	-Xss参数设置线程栈的大小
	
	线程中进行局部变量分配，函数调用，都需要在栈中开辟空间。
	如果空间太小，没有足够的空间分配局部变量或者达不到函数的调用深度，导致程序异常退出。
	如果空间过大，那么开设线程所需的内存成本会上升，系统所能支持的线程总数就会下降。
	
	-Xss20M
	当系统内存被堆使用了，就不可以被栈使用
	
============================================================
5.2.6 堆的比例分配
	-XX:SurvivorRatio   eden空间和s0空间的比例关系
	
	-XX:+PrintGCDetails -Xmn10M -XX:SurvivorRatio=2
	-XX:+PrintGCDetails -XX:NewRatio=2 -Xmx20M -Xms20M
	
============================================================
5.3 垃圾收集基础
	介绍一些垃圾回收方法以及HotSpot虚拟机支持的垃圾回收器
	
	垃圾收集器要处理的基本问题是
	哪些对象需要回收
	何时回收这些对象
	如何回收这些对象
	
	引用计数器  Reference Counting
	对于一个对象A,只要任何一个对象引用了A,则A的引用计数器就+1，当引用失效，引用计数器就减1 为0，表示不再被使用，不能解决循环引用的问题
	
	标记清除算法 Mark Sweep
	标记清除算法 标记阶段和清除阶段 
	在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象，未被标记的对象就是未被引用的垃圾对象。 
	最大问题 产生空间碎片
	
	复制算法
	将原有内存空间分为两块，每次只使用其中的一块，在垃圾回收时，将正在使用的内存中存活的对象复制到未使用的内存块中。之后清除所有对象，交换两个内存的角色，完成垃圾回收。
	高效性建立存活对象少，垃圾对象多的前提下。
	复制算法将内存折半
	suvivor空间中的from和to就是使用这种算法
	
	标记压缩算法 Mark-Compact
	老年代中，而是将所有存活对象压缩到内存的一端。避免产生碎片
	
	增量算法
	让垃圾收集线程和应用程序线程交替执行，切换，垃圾回收总体成本上升，系统吞吐量下降。
	
	分代
	年轻代使用复制算法 老年代使用标记压缩算法
	
	垃圾回收器的类型
	线程数 串行垃圾回收器和并行垃圾回收器
	工作模式 并发式垃圾回收器和独占是垃圾回收器
	碎片处理方式 压缩式垃圾回收器和非压缩式垃圾回收器
	工作内存区间 新生代垃圾收集器和老年代垃圾收集器
	
============================================================
5.3.4 评价GC策略的指标
	系统吞吐量=程序所花时间/系统运行总时间=程序所花时间/(应用程序耗时+GC耗时)
	垃圾回收器的负载=GC耗时/(应用程序耗时+GC耗时)
	停顿时间 垃圾收集器正在运行，应用程序暂停时间
	垃圾回收频率 多长时间运行一次，增加对内存有效降低垃圾发生频率，但会增加回收产生的停顿时间
	反应时间 指一个对象称为垃圾后，多长时间，它锁占据的内存空间会被释放
	堆分配 不同垃圾收集器对堆内存的分配方式可能是不同的
	
============================================================
5.3.5 新生代串行收集器
	串行收集器 它仅仅使用单线程进行垃圾回收 它是独占式的垃圾回收
	
	-XX:+UseSerialGC
	一次垃圾回收前新生代的内存占用量和垃圾回收后的新生代的内存占用量，以及垃圾回收所耗的时间。
	
============================================================
5.3.6 老年代串行收集器
	标记压缩算法，是一个串行的独占式的垃圾回收器
	
============================================================
5.3.7 并行收集器
	并行回收器是工作在新生代的垃圾收集器，知识简单将串行收集器多线程化。也是独占式的垃圾回收器。

============================================================
5.3.8 新生代并行回收 Parallel Scavenge收集器

============================================================
5.3.10 CMS收集器
	CMS收集器主要关注于系统停顿时间
	标记清除算法 多线程并行的垃圾收集器
	
	初始标记 并发标记 重新标记 并发清除 并发重置
	
	CMS收集器虽然没有暴力彻底暂停应用程序线程，但是由于它和应用程序线程并发执行，相互抢占cpu资源，故在CMS执行期内对应用程序吞吐量造成一定的影响。
	
	CMS会当堆内存使用率达到某一阈值，便开始进行垃圾回收，以确保应用程序在CMS工作过程中，依然有足够空间支持应用程序的运行。
	
	如果应用程序内存使用率增长很快，在CMS的执行过程中，已经出现了内存不足的情况，此时，CMS回收就会失败，JVM将启动老年代串行收集器器进行垃圾回收。如果这样，应用程序将完全中断，应用程序的停顿时间可能很长。
	可以与用户程序同时运行，从而降低应用程序的停顿时间。
	
	concurrent mode failure
	
	解决方案 预留一个较大的老年代空间，或者设置一个较小的-XX:CMSInstiatingOccupancyFraction参数，降低CMS触发阈值。
	
============================================================
5.3.11 G1收集器
	标记压缩算法，可以非常精确的停顿控制。
	
============================================================
5.3.12 Stop the World案例
	-Xmx512M -Xms512M -XX:+UseSerialGC -Xloggc:gc.log -XX:+PrintGCDetails
	
============================================================
5.4 常用调优案例和方法

5.4.1 将新对象预留在新生代
	以最大限度避免新对象直接进入老年代的情况。
	-XX:+PrintGCDetails -Xmx20M -Xms20M -Xmn2M
	-XX:+PrintGCDetails -Xmx20M -Xms20M -Xmn6M
	
	-XX:+PrintGCDetails -Xmx20M -Xms20M -Xmn10M -XX:SurvivorRatio=8 
	
	-XX:+PrintGCDetails -Xmx20M -Xms20M -Xmn10M -XX:SurvivorRatio=8 -XX:TargetSurvivorRatio=90
5.4.2 大对象进入老年代
	长命大对象直接放入到老年代
	新生代分配大对象，很可能导致空间不足
	
============================================================
5.4.3 设置对象进入老年代年龄
	
============================================================
5.4.4 稳定与震荡的堆大小
	
============================================================
5.5 实用JVM参数
	
	没看太懂
	
	
	
	
	
	
	
	
	
	
	
	
	
	