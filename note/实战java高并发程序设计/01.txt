多线程间的协调性、乱序性都成为正确执行的障碍。

如何保证线程安全，如何正确理解线程的无序性，可见性，如何尽可能提高并行程序的设计。

	同步和异步

	同步方法调用一旦开始，调用者必须等到方法返回后，才能继续后续的行为。
	异步方法调用更像一个消息的传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。

	并发和并行

	并发侧重于多个任务交替执行，而多个任务之间有可能还是串行的。
	并行是真正意义上的同时执行。

	1.2.3 临界区

	临界区用来表示一种公共资源或者共享数据，可以被多个线程使用。

	1.2.4 阻塞和非阻塞

	比如一个线程占用了临界区资源，那么其他所有需要这个资源的线程就
	必须在这个临界区中进行等待。等待会导致线程的挂起，这种情况就是阻塞。

	1.2.5 死锁 饥饿 活锁

	死锁 相互占用了各自的资源，不肯放让
	饥饿 某一个或者多个线程因为种种原因无法获取所需要的资源，导致一直无法执行
	活锁 秉承着谦让的原则，主动将资源释放给他人使用，那么就会出现资源不断的在两个线程中跳动，而没有一个线程可以同时拿到所有资源而正常执行。

============================================================
1.3 并发的级别
	阻塞 无饥饿 无障碍 无锁 无等待
	1.3.1 阻塞 一个线程是阻塞的，那么其他线程释放资源之前，当前线程是无法执行，当我们使用synchronized关键字或者重入锁。
	
	1.3.2 无饥饿 
	线程的级别一样 或者公平锁  就不会出现饥饿
	
	1.3.3 无障碍 
	认为多个线程之间很有可能不发生冲突，都进入临界区，或者这种概率不大，因此大家都可以无障碍的执行，但是一旦检测到冲突，就应该进行回滚。
	一致性标记，线程在操作之前，先读取并保存这个标记，再操作完成之后，再次读取，检查这个标记是否被更改过，如果两者是一致的。而任何对资源的修改操作的线程，在修改数据前，都需要更新这个一致性标记，表示线程不再安全。
	
	1.3.4 无锁
	无锁，无锁的并行总能保证有一个线程可以胜出。不至于全军覆没。
	
	1.3.5 无等待
	读锁都是无等待的，它们不会引起任何冲突。但是写数据的时候，先取得原始数据的副本。接着只修改副本数据。修改完成后，在合适的时机写数据。
	
	Java内存模型主要围绕多线程的原子性 可见性 有序性来建立的。
	
	1.5.2
	可见性 当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。
	缓存优化 硬件优化 编辑器的优化 都可能导致一个线程的修改不会立即被其他线程察觉
	
	1.5.3 有序性
	并发，程序的执行可能会出现乱序，执行代码的顺序变乱了。
	
	









































































































































