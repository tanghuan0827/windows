第二章
2.1
	无状态的类一定是线程安全的
	读取 修改 写入
	由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况 竞态条件
	
	观察结果失效就是大多数竞态条件的本质  先检查后执行
	
	延迟初始化的竞态条件
	
	不恰当的执行时序， 基于对象之前的状态来定义对象状态的转换
	
==================================================================
2.2.3 复合操作
	在某个线程修改变量时，通过某种方式防止其他线程使用这个变量
	从而确保其他线程只能在修改操作完成之前或者之后读取和修改状态 而不是在修改状态的过程中
	
	原子性 
	
	第一种方式
	状态 计数器是线程安全的 Servlet类也是线程安全
==================================================================
2.3 加锁机制
	涉及多个状态 ，要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量
	
2.3.1 内置锁
	同步代码块 
	synchronized(lock){
		//访问或修改由锁保护的共享状态
	}
	
	性能问题 互斥性 每个java对象都可以用作一个实现同步的锁
	
2.3.2 重入
	某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功
	
	对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。
	
	内置锁
	
	多个操作合并成一个复合操作，还是需要额外的加锁机制
	
==================================================================
2.5 活跃性与性能
	不良并发。 缩小同步代码块的作用范围。 
	尽量将不影响共享状态且执行时间较长的操作从同步代码块分离出去。
	
==================================================================
第三章  对象的共享
	当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。
	
	==================================================================
	3.1 可见性
	volatile 变量的读取和写入操作都是原子操作的
	
	==================================================================
	3.1.3 加锁与可见性
	访问某个共享且可变的变量要求所有的线程在同一个锁上同步 
	确保某个线程写入改变量对于其他线程是可见的
	
	所有执行读操作或者写操作的线程都必须在同一个锁上同步
	
	所有线程都能看到共享变量的最新值
	
	==================================================================
	3.1.4 Volatile变量
	
	volatile不足以确保递增操作的原子性
	
	==================================================================
	3.2 发布与逸出
	发布 使对象能在当前作用域之外的代码中使用 
	当某个不该发布的对象被发布了，这种情况就叫做逸出。
	
	如果想在构造函数中注册一个事件监听或者启动一个线程，可以使用一个私有的构造
		函数和一个公共的工厂方法。从而避免不正确的构造
		
	==================================================================
	3.3 线程封闭
	当访问共享可变数据时，通常需要使用同步
	单线程内访问数据，就不需要同步， 这种技术称为线程封闭
	
	jdbc 线程从连接池获取一个connection对象，并且用改对象来处理请求。返回给连接池。 
	线程封闭性 局部变量 和ThreadLocal
	
	==================================================================
	3.3.1 Ad-hoc线程封闭
	维护线程封闭的职能完全有程序来承担，很脆弱。
	
	==================================================================
	3.3.2 栈封闭
	只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中。
	
	任何方法都无法获得对基本类型的引用，基本类型的局部变量始终封闭在线程内
	
	只有编写代码的开发人员才知道哪些对象需要被封闭到执行线程中，以及被封闭的
		对象是否是线程安全的。防止错误使用使对象逸出。
		
	==================================================================
	3.3.3 ThreadLocal类
	这个类使线程中的某个值与保存值得对象关联起来。get set为每个使用该变量的线程
		都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值
		
	每个线程都有自己的连接 threadlocal
	
	==================================================================
	3.4 不变性
	使用不可变对象
	
	即使对象中的所有域都是final类型的，这个对象也仍然是可变的，因为在final类型的域
	中可以保存对可变对象的引用。
	
	==================================================================
	3.5.4 事实不可变对象
	其状态在发布后不会再改变
	
	==================================================================
	3.5.5 可变对象
	
	==================================================================
	3.5.6 安全的共享对象
	
==================================================================
第四章 对象组合
	使用不同的锁，所以不是线程安全的
	
	
==================================================================
第五章
	如果不希望迭代期间对容器进行加锁，替代方法克隆，并在副本上进行迭代。
	
	封装对象的同步机制同样有助于实施同步策略
	
	==================================================================
	5.2 并发容器
	通过并发容器来替换同步容器，可以极大的提高伸缩性并降低风险。
	
	
	
	
	